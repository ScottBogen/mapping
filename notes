Task: 

Given a reference genome sequence G of length N, and a set of 
m sequences ("reads") each of length L, identify the genomic 
locus to which each read best aligns. 

- N is very very large 

- L is relatively small (~100)

- if M denotes the sum of lengths of all m reads, then typically
  M tends to be anywhere between 10x and 100x bigger than N


- for example, if the reference genome's length N is 10^6 chars, 
  and if the coverage is 10x, and if the reads are all of length 
  L 100 characters, then the number of reads m is given by:
    N * coverage / L = 10^6 * 10 / 100 = 10^5 reads


What we need is a fast and aefficient way to first identify potential locations along the reference genome to which the read exhibits a good promise of aligning up, and then perform a more rigorous alignment computation of the read against those short-listed loci alone. The goal therefore is to map the reads to the reference genome in such a way so as to drastically reduce both the number of alignment tasks and the size of each alignment task. This can be achieved using a combination of the suffix trees and alignment methods that you have already developed.



****** ReadMapping: MAIN begin ******

Step 1: ConstructST 

    Construct the Suffix Tree for G using MCC. 
    The only thing I need to change is when I insert a new node or leaf, initialize start_index and end_index to -1

Step 2: PrepareST 



Step 3: MapReads

    for i=1 to m, do {
        a. let r_i be the ith read, let l denote the length of r_i 

        b. FindLocs:

            Find the set L_i of all locations on the genome G that share a longest common substring of length >= x characters with the read r_i. For example, if the reference genome sequence is the string "accgaccgtact" and the read is "tacaccg", then the LCS between the read and the reference is "accg", which occurs starting at two locations - from index 1 and index 5 along the reference genome. So the L_i for this read should be output as {1,5}, assuming x is 4 or less. 

            The implementation of this step will use the Suffix Tree constructed in Step 1. x is a parameter to the code, and in practice can be calculated as a funciton of both th eread length and the estimated error rate of the sequencing process that led to the generation of the reads. For this project, just use ***x=25***. 

            Note that the set L_i represents a candidate list of all indices j's along the reference genome G which are tsarting positions for the longest common exact match of length >=x characters between r_i and G. (This also implies 1 <= j <= N-x + 1)

            Let the number of identified indices along G for r_i be    |L_i|. 

        c. Align:

            For each j in L_i {
                1. Extract substring G[j-1... j+1], where l is the length of the read. Of course, make sure to handle boundary cases here - i.e., if j is at the beginning or end parts of G, then correspondingly retrieve as many characters that exist in G without going out of bounds.

                2. Perform a local alignment computation (using Smith-Waterman) between read r_i and G[j-1... j+1]. For the alignment, you can use the following params:
                    ma: +1
                    mi: -2
                    i:  -2
                    h:  -5
                    g:  -1

                After computing the DP table, record two pieces of information corresponding to the optimal local alignment:
                    a. the # of matches     (#matches)
                    b. the alignment length (#alignlen)
                        this is just the # of aligned columns in the final alignment, i.e. # matches + # mismatches + #gaps. 

                3. Let PercentIdentity = #matches / #alignlen

                4. Let LengthCoverage = #alignlen / 1 

                5. If PercentIdentity >= X% && LengthCoverage >= Y% {
                    Then the alignment is "good quality"

                    Keep track of and output the best quality alignment 

                    By default, set X = 90% and Y = 80%

                    Is this value for LengthCoverage > previously seen? 
                        if so, then update the new value of LengthCoverage and record this as the best hit. Best hit = (j0, j1), the start and end indices of the substring on the reference genome sequence corresponding to this optimal local alignment
                }
            }       
        } (end MapReads)
    4. Step 4: Output 
        Output the bes thit calculated in the last step as the hit for read r_i. The output can be simply: 
            <Read_name> <Start index of hit> <End index of hit>

        If no hit was identified, output <Read_name> "No hit found"
********************* ReadMapping: MAIN end ***********************



--- ALGORITHM FOR FINDLOC ---

The goal of this function is to find a LCS between an input read r and the reference genome G, and return all its starting positions along the reference genome. To do this, we will try to reuse as much of the function FindPath as possible. The main steps are as follows:

Note: Throughout the procedure, the suffix tree will be read-only. We write nothing.

0: Initilizations

    i. struct node* T = root of suffix tree 
    ii. int read_ptr = 1;       // read pointer (use 0 in the code)

    Update read_ptr as you match up each consecutive character along the read successfully. Don't increment if there is a mismatch.

1. Starting at T = root, find a path below the node T in the tree that spells out as many remaining characters of r starting from the read_ptr. This would be a ismple call to FindPath() starting from root and the startin gindex for comparison on the read (read_ptr)

    probably something like `FindPath(t, root, S, read_ptr);`

2. Let's say, after some number of successful character comparisons, a mismatch is observed and so the matching path terminates. There are two subcases here. The matching path could either terminate at the end of an edge (case A) or could terminate in the middle of an edge (case B). In either case, let u be the internal node last visited along th ematching path. In case A, u will be the node at which this edge ends. For case B, u will be the node from which this edge spawns off. If case B, then decreaes the value of read_ptr by the number of characters that successfully matched below u along ht eedge before you hit a mismatch - i.e., if you matched r characters successfully along an edge below u before you hit a mismatch along that edge, then read_ptr = read_ptr - r. This will reset read_ptr back to where it was right after u. You don't have to do this for case A. 

3. If the string-depth(u) >= x and if the string depth is the longest seen so far in tihs read, then store a pointer, called "deepestNode" to the node u. We will update this pointer in future iterations if need be.

4. Now simply take the suffix link pointer from u to v. Set T=v and then go back to step 1 and repeat the process until you find hte next mismatching point and so on.

5. At some point you will exhaust comparing all chars in your read. That signifies the end of iterations. Exit out of the while/for loop (for steps 1-4).

Note: If I can't get SL to work, I can just do FindPath from the root for steps 2-5. Less cool but it still works. 

6. Upon exiting, go to the node pointed to by the most up-to-date deepestNode pointer. The suffix ids in the interval a[deepestNode->start_index] to A[deepestNode->end_index] is to be returned as the candidate list of genomic positions L_i for the read. 



********* Algorithm for PrepareST function (step 2) **********

The goal of this step is ot compute the leaf list corresponding to each internal node and leaf in the suffix tree. 

Algorithm:

Note: Make sure all start and end indices are -1

This function will calculate the leaf lists of all the nodes with a string-depth of at least x while simultaneously populating array A (the list of leaf suffix IDs from left to right)

1. Create an Array of size n (string length of input + 1 for $) and initialize content with -1

2. Initialize a global integer variable nextIndex to the start of the A array (init to 0). This variable represents the next index in A which has to be populated.

3. Call DFS_PrepareST(root,A);  // where root is the root of the suffix tree.

DFS_PrepareST(struct node* T, int A[]) {

    if (T==NULL) { return; }
    if (!T->children) {
        A[nextIndex] = suffix ID of this leaf node
        if (T->depth >= x) {
            T->start_index = nextIndex;
            T->end_index = nextIndex;
        }
        nextIndex++;
        return;
    }

    // case: T is an internal node

    for each child u under T from left to right {
        DFS_PrepareST(u, A);    // recursively visit each child of the current internal node 
    }
    // the above step would have computed the leaf lists for all of T's children. Now it's time to set the leaf list interval for T.

    if (T->depth >= x) {
        let u_left = T's first child 
        let u_right = T's last child 
        T->start_index = u_left->start_index;
        T->end_index = u_right->end_index;
    }
}